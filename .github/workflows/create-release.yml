---
name: Create Release

concurrency:
  group: release-${{ inputs.tag-name }}
  cancel-in-progress: false

on:
  workflow_call:
    inputs:
      tag-name:
        required: true
        type: string
        description: 'Tag name for the release'
      release-name:
        required: true
        type: string
        description: 'Display name for the release'
      is-prerelease:
        required: false
        type: boolean
        default: false
        description: 'Whether this is a prerelease'
      release-body:
        required: false
        type: string
        description: 'Release body text'
      is-latest:
        required: false
        type: boolean
        default: false
        description: 'Whether this is a latest build (affects which files are included)'

permissions:
  contents: write
  packages: write
  actions: read

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # we need full history for tags

      - name: Download all artifacts
        uses: actions/download-artifact@v6

      - name: Compute artifact list
        id: files
        shell: bash
        run: |
          if [[ "${{ inputs.is-latest }}" == "true" ]]; then
            JAR_PATTERN='linux-windows-builds/build/ECUxPlot-latest.jar'
          else
            JAR_PATTERN='linux-windows-builds/build/ECUxPlot-*.jar'
          fi
          {
            echo "list<<EOF"
            echo "macos-builds/build/*.dmg"
            echo "macos-builds/ECUxPlot.dmg"
            echo "macos-builds/build/*.zip"
            echo "$JAR_PATTERN"
            echo "linux-windows-builds/build/*.tar.gz"
            echo "linux-windows-builds/build/*.exe"
            echo "linux-windows-builds/ECUxPlot-setup.exe"
            echo "linux-windows-builds/ECUxPlot.jar"
            echo "linux-windows-builds/mapdump.jar"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Parse changelog for release notes
        id: parse_changelog
        run: |
          TAG_NAME="${{ inputs.tag-name }}"
          VERSION=${TAG_NAME#v}

          if [ "$TAG_NAME" = "latest" ]; then
            echo "Using Unreleased section for 'latest' tag"
            if grep -q "## \[Unreleased\]" CHANGELOG.md; then
              awk "/## \[Unreleased\]/,/^## \[[0-9]/ { if (!/^## \[Unreleased\]/ && !/^## \[[0-9]/) print }" CHANGELOG.md > /tmp/changelog_section.txt
            else
              echo "No Unreleased section found in changelog"
              echo "changelog_content=" >> $GITHUB_OUTPUT
              exit 0
            fi
          elif grep -q "## \[$VERSION\]" CHANGELOG.md; then
            sed -n "/## \[$VERSION\]/,/^## \[/p" CHANGELOG.md | sed '1d;$d' > /tmp/changelog_section.txt
          elif grep -q "## \[Unreleased\]" CHANGELOG.md; then
            awk "/## \[Unreleased\]/,/^## \[[0-9]/ { if (!/^## \[Unreleased\]/ && !/^## \[[0-9]/) print }" CHANGELOG.md > /tmp/changelog_section.txt
          else
            echo "No changelog section found for version $VERSION or Unreleased"
            echo "changelog_content=" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ -s /tmp/changelog_section.txt ]; then
            sed '/^$/d' /tmp/changelog_section.txt | sed 's/^### /#### /g' | sed 's/^- /- /g' > /tmp/changelog_clean.txt
            CHANGELOG_CONTENT=$(cat /tmp/changelog_clean.txt)
            echo "changelog_content<<EOF" >> $GITHUB_OUTPUT
            echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "changelog_content=" >> $GITHUB_OUTPUT
          fi

      - name: Backup & force-move tag to this commit
        id: move_tag
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git fetch --tags --prune --force origin

          TAG="${{ inputs.tag-name }}"
          PREV_HASH="$(git rev-list -n1 "refs/tags/$TAG" 2>/dev/null || true)"
          if [[ -z "$PREV_HASH" ]]; then
            PREV_HASH="$(git ls-remote --tags origin "refs/tags/$TAG" | awk '{print $1}' || true)"
          fi
          echo "prev_hash=${PREV_HASH}" >> "$GITHUB_OUTPUT"

          git tag -f "$TAG" "${GITHUB_SHA}"
          git push -f origin "refs/tags/$TAG"

      - name: Create release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.tag-name }}
          name: ${{ inputs.release-name }}
          draft: false
          prerelease: ${{ inputs.is-prerelease }}
          target_commitish: ${{ github.sha }}
          generate_release_notes: true
          body: |
            ${{ inputs.release-body }}

            ## Changelog

            ${{ steps.parse_changelog.outputs.changelog_content }}
          files: ${{ steps.files.outputs.list }}
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore previous tag if release failed
        if: steps.create_release.outcome != 'success' && steps.move_tag.outputs.prev_hash != ''
        shell: bash
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          echo "Release failed, restoring ${{ inputs.tag-name }} to ${{ steps.move_tag.outputs.prev_hash }}"
          git tag -f "${{ inputs.tag-name }}" "${{ steps.move_tag.outputs.prev_hash }}"
          git push -f origin "refs/tags/${{ inputs.tag-name }}"

      - name: Purge older pre-releases and drafts (keep the one we just made)
        if: steps.create_release.outcome == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"
          CURR_TAG="${{ inputs.tag-name }}"

          # Delete any prerelease OR draft whose tag != current tag (or has no tag)
          gh api "repos/$REPO/releases?per_page=100" \
          | jq -r --arg CURR_TAG "$CURR_TAG" '
              .[]
              | select((.prerelease == true or .draft == true) and (.tag_name // "") != $CURR_TAG)
              | [.id, (.tag_name // ""), (.draft // false), (.prerelease // false)]
              | @tsv
            ' \
          | while IFS=$'\t' read -r rel_id tag_name is_draft is_pre; do
              # If tag_name is present, prefer deleting by tag (also try to delete the tag ref)
              if [[ -n "$tag_name" ]]; then
                echo "Deleting $( [[ "$is_draft" == "true" ]] && echo draft || echo pre-release ) by tag: $tag_name"
                gh release delete "$tag_name" -R "$REPO" -y || true
                gh api -X DELETE "repos/$REPO/git/refs/tags/$tag_name" >/dev/null 2>&1 || true
              else
                # No tag_name (draft with no tag): delete by numeric id
                echo "Deleting draft with no tag by id: $rel_id"
                gh api -X DELETE "repos/$REPO/releases/$rel_id" || true
              fi
            done

      - name: Delete releases (draft or published) whose tag ref is missing
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ github.repository }}"

          # Any release (draft=false/true) whose tag_name is empty OR whose git ref doesn't exist
          gh api "repos/$REPO/releases?per_page=100" \
          | jq -r '
              .[]
              | [.id, (.tag_name // ""), (.draft // false)]
              | @tsv
            ' \
          | while IFS=$'\t' read -r rel_id tag_name is_draft; do
              if [[ -z "$tag_name" ]]; then
                echo "Deleting release id=$rel_id with empty tag_name"
                gh api -X DELETE "repos/$REPO/releases/$rel_id" || true
                continue
              fi
              if ! gh api "repos/$REPO/git/ref/tags/$tag_name" >/dev/null 2>&1; then
                echo "Deleting release with missing tag ref: $tag_name (draft=$is_draft)"
                gh release delete "$tag_name" -R "$REPO" -y || true
              fi
            done
